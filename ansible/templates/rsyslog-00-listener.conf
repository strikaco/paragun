# Where to get logs from
input(type="imudp" port="514"
      ruleset="writeRemoteData")
input(type="imtcp" port="10514"
      ruleset="writeRemoteData")
input(type="imrelp" port="20514"
      ruleset="writeRemoteData")

# Where to store/forward these logs
ruleset(name="writeRemoteData"
        queue.type="linkedlist"
        queue.size="250000"
        queue.dequeueBatchSize="4096"
        queue.workerThreads="4"
        queue.workerThreadMinimumMessages="60000"
       ) {
       
    # Check for token; reject if none found.
    #
    # At this point we cannot check to see if the token is actually valid-- 
    # but storage is cheap whereas downstream message processing is not, so
    # we'll store anything that pretends to be valid and will filter out
    # ineligible messages later.
    #
    # Token MUST be in UUID4 format, followed by the @P4R4GN suffix.
    :rawmsg, !ereregex, ".*[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-4[a-fA-F0-9]{3}-[89aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}\@P4R4GN.*" stop
    
    # Store locally
    action(
        type="omfile" 
        dynaFile="RemoteDynaFileTemplate"
        ioBufferSize="64k"
        flushOnTXEnd="off"
        asyncWriting="on"
    )
    # Forward to parsers
    #action(type="omfwd"
    #    target="127.0.0.1" 
    #    port="514" 
    #    protocol="tcp"
    #    action.resumeRetryCount="100"
    #    queue.type="linkedList" 
    #    queue.size="20000"
    #)
}